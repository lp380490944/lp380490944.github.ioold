---
layout: post
title: "面试的自我总结"
description: ""
category : lessons
tags: []
---




#面试的自我总结


###1、堆和栈的区别？
答：管理方式：对于栈来讲，是由编译器自动管理的，无需我们手动控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。

###2、数组和链表的区别？
答：数组是将元素在内存中连续存放，由于每个元素占用内存相同，可以通过下标迅速访问数组中的任何元素。

链表恰恰相反，链表中的元素在内存中不是顺序存储的，而是通过存在元素的指针联系到一起。

###3、delegate和notification什么区别，，什么情况使用？
答：delegate：消息发送者（sender）告知接收者（receiver）某个事件将要发生，delegate同意然后发送响应者响应事件，delegate机制使得接收者可以可以改变发送者的行为。
通常发送者和接收者是一对多的关系。

NOtification：消息的发送者告知接收者事件已经发生或者将要发送，仅此而已，接收者并不能反过来影响发送者的行为。通常发送者和接收者的关系是间接的多对多关系
###4、什么是MVC，为什么使用MVC，有什么好处？
答： 分别为： 模型(Model),视图(View)和控制Controller)。          模型（Model） “数据模型”（Model）用于封装与应用程序的业务逻辑相关的数据以及对数据的处理方法。        “模型”有对数据直接访问的权力，例如对数据库的访问。          视图（View） 视图层能够实现数据有目的显示。          控制器（Controller） 控制器起到不同层面间的组织作用，用于控制应用程序的流程
          
          
###5、从一个数组中找出重复的元素打印出来
					     NSArray *arr = [NSArrayarrayWithObjects:@"1",@"2",@"1",nil];     NSSet *set = [NSSetsetWithArray:arr];     NSLog(@"%@",[setallObjects]);
     
###6、UITableView能否绑定多个数据源？答：不能###7、一个UIViewController能否管理多个UITableView ?答：可以####9、同步请求和异步请求什么区别？
答：发送同步请求，程序将停止用户交互，直至服务器返回数据完成，才可以进行下一步操作，异步请求不会阻塞主线程，而会建立一个新的线程来操作，用户发出异步请求后，依然可以对UI进行操作，程序可以继续运行
###10、iOS中的多线程操作、多线程方式
答：iOS提供了方便的多线程调用机制:NSOperation和NSOperationQueue。它的使用方法也很简单，一般都是将NSOperation对象加入到NSOperationQueue队列中，加入后队列就开始处理，知道任务操作完成。
###11、UIViewController的生命周期
答：当一个视图控制器被创建，并在屏幕上显示的时候。 代码的执行顺序      // 视图显示在屏幕上的顺序     1、 alloc                    创建对象，分配空间。    2、init (initWithNibName)    初始化对象,初始化数据。    3、loadView                   从nib载入视图, 这一步不需要去干涉。除非没有使用xib文件创建视图。    4、viewDidLoad                加载完毕，可以进行自定义数据以及动态创建其他控件。    5、viewWillAppear             视图将出现在屏幕之前，马上这个视图即将显示在屏幕上。   6、viewDidAppear              视图已在屏幕上渲染完成。   // 视图将被从屏幕上移除的顺序    1、viewWillDisappear          视图将被从屏幕上移除之前执行。    2、viewDidDisappear           视图已经被从屏幕上移除。    3、dealloc                    视图被销毁，此时需要在init和viewDidLoad中创建的对象进行释放。    4、viewDidUnload              出现内存警告在内存不足时执行，并对所有非当前显示的controller执行。     本视图的所有子视图将被销毁，以释放内存,此时开发者需要手动对viewLoad、viewDidLoad中创建的对象释放内存。因为当这个视图再次显示在屏幕上的时候，viewLoad、viewDidLoad 再次被调用，以便再次构造视图####12、Autorerelease对象什么时候释放？
答：autorelease实际上只是把对release的调用延迟了，对于每一个Autorelease，系统只是把该Object放入了当前的Autorelease pool中，当该pool被释放时，该pool中的所有Object会被调用Release。###13、iOS数据持久化方式  答：四种：属性列表、对象归档、SQLite3和Core Data、NSUserdefault。
  
###14、Object－c的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？ 答：Object-c的类不可以多重继承；可以实现多个接口，通过实现多个接口可以完成C++的多重继承；Category是类别，一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。
 
###15. #import 跟#include 又什么区别，@class呢, ＃import<> 跟 #import”"又什么区别？
答：#import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字,使 用#import头文件会自动只导入一次，不会重复导入，相当于#include和#pragma once；@class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含；#import<>用来包含系 统的头文件，#import””用来包含用户头文件。

###16.属性readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用？
答：readwrite 是可读可写特性；需要生成getter方法和setter方法时readonly 是只读特性  只会生成getter方法 不会生成setter方法 ;不希望属性在类外改变

assign 是赋值特性，setter方法将传入参数赋值给实例变量；仅设置变量时

retain 表示持有特性，setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1;

copy 表示赋值特性，setter方法将传入对象复制一份；需要完全一份新的变量时。

nonatomic 非原子操作，决定编译器生成的setter getter是否是原子操作，atomic表示多线程安全，一般使用nonatomic.

###17.常见的object-c的数据类型有那些， 和C的基本数据类型有什么区别？如：NSInteger和int
答：object-c的数据类型有 NSString，NSNumber，NSArray，NSMutableArray，NSData等等，这些都是class，创建后便是对象，而C语言的基本数据类型int，只是一定字节的内存空间，用于存放数值；而object-c的NSNumber包含有父类NSObject的方法和 NSNumber自己的方法，可以完成复杂的操作。

###18.Objective-C如何对内存管理的,说说你的看法和解决方法? 答：Objective-C的内存管理主要有三种方式ARC（自动内存计数）、手动内存计数、内存池。解决方法的话： 谁持有，谁释放。
###19.如何对iOS设备进行性能测试?
答：Profile-> Instruments ->Time Profiler

###20.Object C中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码、方法又是什么？
答：线程创建有三种方法：使用NSThread创建、使用 GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue;在主线程执行代码，方法是 performSelectorOnMainThread，如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone: 
###21.描述一下iOS SDK中如何实现MVC的开发模式？
答：MVC是：模型--视图--控制  开发模式，对于iOS SDK，所有的View都是视图层的，它应该独立于模型层，由视图控制层来控制。所有的用户数据都是模型层，它应该独立于视图。所有的ViewController都是控制层，由它负责控制视图，访问模型数据。
###22.定义属性时，什么情况使用copy、assign、retain？
答：assign用于简单数据类型，如NSInteger,double,bool, 其实还有后面的block等；
 retain和copy用于对象，copy用于当a指向一个对象，b也想指向同样的对象的时候，如果用assign，a如果释放，再调用b会crash,如果用copy 的方式，a和b各自有自己的内存，  就可以解决这个问题。       retain 会使计数器加一，也可以解决assign的问题。       另外：atomic和nonatomic用来决定编译器生成的getter和setter是否为原子操作。在多线程环境下，原子操作是必要的，否则有可能引起错误的结果。 加了atomic，setter函数会变成下面这样：      
      
       if (property != newValue) {       [property release];       property = [newValue retain];       }###23. Object-C有私有方法吗？私有变量呢？
答：objective-c – 类里面的方法只有两种, 静态方法和实例方法，所有实例变量默认都是私有的，所有实例方法默认都是公有的。
###24.浅复制和深复制的区别？//浅拷贝和深拷贝
浅层复制（copy）：只复制指向对象的指针，而不复制引用对象本身。//通过对象的指针来访问这个对象深层复制（mutableCopy）：复制引用对象本身意思就是有个A对象，复制一份后得到A_copy对象后，对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是是一个指针，对象本身资源还是只有一份，那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改，这其实违背了我们复制拷贝的一个思想。深复制就好理解了,内存中存在了两份独立对象本身。//当修改A时，A copy不变

###25.自动释放池是什么,如何工作
答： 当您向一个对象发送一个autorelease消息时，Cocoa就会将该对 象的一个引用放入到最新的自动释放池。        它仍然是个正当的对象，因此自动释放池定义的作用域内的其它对象可以向它发送消息。当程序执行到作用域结束的位置时，        自动释放池就会被释放，池中的所有对象也就被释放###26.单件实例是什么
 答： Foundation 和 Application Kit 框架中的一些类只允许创建单件对象，即这些类在当前进程中的唯一实例。       举例：NSFileManager 和NSWorkspace类在使用时都是基于进程进行单件对象的实例化。       当向这些类请求实例的时候，它们会向您传递单一实例的一个引用，如果该实例还不存在，则首先进行实例的分配 和初始化。###27.类别的作用？继承和类别在实现中有何区别？
 答：category 可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改。       并且如果类别和原来类中的方法产生名称冲突，则类别将覆盖原来的方法，因为类别具有更高的优先级。 类别主要有3个作用：
       (1)将类的实现分散到多个不同文件或多个不同框架中。       (2)创建对私有方法的前向引用。       (3)向对象添加非正式协议。        继承可以增加，修改或者删除方法，并且可以增加属性###28.类别和类扩展的区别。
 答：category和extensions的不同在于 后者可以添加属性。另外后者添加的方法是必须要实现的。 extensions可以认为是一个私有的Category

###29.KVO and KVC? 答：kvc:键 - 值编码是一种间接访问对象的属性，使用字符串来标识属性，而不是通过调用存取方法，直接或通过实例变量访问的机制。 很多情况下可以简化程序代码。apple文档其实给了一个很好的例子。 kvo:键值观察机制，他提供了观察某一属性变化的方法，极大的简化了代码。 具体用看到用到过的一个地方是对于按钮点击变化状态的的监控。 比如我自定义的一个button [cpp]  [self addObserver:self forKeyPath:@"highlighted" options:0 context:nil];      #pragma mark KVO    - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context  {       if ([keyPath isEqualToString:@"highlighted"] ) {             [self setNeedsDisplay];        }  }对于系统是根据keypath去取的到相应的值发生改变，理论上来说是和kvc机制的道理是一样的。 对于kvc机制如何通过key寻找到value： “当通过KVC调用对象时，比如：[self valueForKey:@”someKey”]时，程序会自动试图通过几种不同的方式解析这个调用。首先查找对象是否带有 someKey 这个方法，如果没找到，会继续查找对象是否带有someKey这个实例变量（iVar），如果还没有找到，程序会继续试图调用-(id) valueForUndefinedKey:这个方法。如果这个方法还是没有被实现的话，程序会抛出一个NSUndefinedKeyException异常错误。  (cocoachina.com注：Key-Value Coding查找方法的时候，不仅仅会查找someKey这个方法，还会查找getsomeKey这个方法，前面加一个get，或者_someKey以及_getsomeKey这几种形式。同时，查找实例变量的时候也会不仅仅查找someKey这个变量，也会查找_someKey这个变量是否存在。）   设计valueForUndefinedKey:方法的主要目的是当你使用-(id)valueForKey方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。这样做有很多好处，下面的两个例子说明了这样做的好处。“ 来至cocoa，这个说法应该挺有道理。      因为我们知道button却是存在一个highlighted实例变量.因此为何上面我们只是add一个相关的keypath就行了，      可以按照kvc查找的逻辑理解，就说的过去了###30.代理的作用？
答：代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。 另外一点，代理可以理解为java中的回调监听机制的一种类似。